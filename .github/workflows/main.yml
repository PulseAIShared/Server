name: CI/CD Pipeline with Auto SSL
on:
  push:
    branches:
      - main
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      
      # Step 4: Generate self-signed SSL certificate for IP address
      - name: Generate SSL certificate for IP address
        run: |
          # Create directories
          mkdir -p ssl
          
          # Get the droplet IP from secrets
          DROPLET_IP="${{ secrets.DIGITALOCEAN_DROPLET_IP }}"
          
          # Generate self-signed certificate for IP address
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout ssl/private.key \
            -out ssl/certificate.crt \
            -subj "/C=US/ST=State/L=City/O=PulseAI/CN=${DROPLET_IP}" \
            -addext "subjectAltName=IP:${DROPLET_IP}"
          
          echo "Generated SSL certificate for IP: ${DROPLET_IP}"
      
      # Step 5: Prepare Nginx files
      - name: Prepare Nginx files
        run: |
          # Create nginx.conf
          cat > nginx.conf << 'EOL'
          user  nginx;
          worker_processes  auto;
          
          error_log  /var/log/nginx/error.log notice;
          pid        /var/run/nginx.pid;
          
          events {
              worker_connections  1024;
          }
          
          http {
              include       /etc/nginx/mime.types;
              default_type  application/octet-stream;
              
              log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                                '$status $body_bytes_sent "$http_referer" '
                                '"$http_user_agent" "$http_x_forwarded_for"';
              
              access_log  /var/log/nginx/access.log  main;
              
              sendfile        on;
              keepalive_timeout  65;
              
              # Rate limiting
              limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
              
              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header Referrer-Policy "strict-origin-when-cross-origin" always;
              
              server {
                  listen 80;
                  server_name ${{ secrets.DIGITALOCEAN_DROPLET_IP }} localhost;
                  
                  # Redirect all HTTP traffic to HTTPS
                  location / {
                      return 301 https://$host$request_uri;
                  }
              }
              
              server {
                  listen 443 ssl;
                  http2 on;
                  server_name ${{ secrets.DIGITALOCEAN_DROPLET_IP }} localhost;
                  
                  # SSL Configuration
                  ssl_certificate /etc/nginx/ssl/certificate.crt;
                  ssl_certificate_key /etc/nginx/ssl/private.key;
                  
                  # Modern SSL configuration
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
                  ssl_prefer_server_ciphers off;
                  ssl_session_timeout 1d;
                  ssl_session_cache shared:SSL:50m;
                  ssl_stapling on;
                  ssl_stapling_verify on;
                  
                  # HSTS (Optional - uncomment if you want strict transport security)
                  # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
                  
                  # API endpoints
                  location / {
                      # Rate limiting
                      limit_req zone=api burst=20 nodelay;
                      
                      # Proxy configuration
                      proxy_pass http://api:5000;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection keep-alive;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $server_name;
                      proxy_cache_bypass $http_upgrade;
                      
                      # Timeouts
                      proxy_connect_timeout 30s;
                      proxy_send_timeout 30s;
                      proxy_read_timeout 30s;
                      
                      # Buffer settings
                      proxy_buffering on;
                      proxy_buffer_size 4k;
                      proxy_buffers 8 4k;
                  }
                  
                  # Health check endpoint
                  location /health {
                      access_log off;
                      proxy_pass http://api:5000/health;
                  }
              }
          }
          EOL
          
          # Create Dockerfile.nginx
          cat > Dockerfile.nginx << 'EOL'
          FROM nginx:latest
          
          # Install openssl for certificate validation
          RUN apt-get update && apt-get install -y openssl && rm -rf /var/lib/apt/lists/*
          
          # Create SSL directory and certbot directory
          RUN mkdir -p /etc/nginx/ssl /var/www/certbot
          
          # Copy the SSL certificates
          COPY ssl/certificate.crt /etc/nginx/ssl/certificate.crt
          COPY ssl/private.key /etc/nginx/ssl/private.key
          
          # Copy the custom nginx.conf
          COPY nginx.conf /etc/nginx/nginx.conf
          
          # Set proper permissions
          RUN chmod 644 /etc/nginx/ssl/certificate.crt && \
              chmod 600 /etc/nginx/ssl/private.key && \
              chown root:root /etc/nginx/ssl/*
          
          # Validate certificate
          RUN openssl x509 -in /etc/nginx/ssl/certificate.crt -text -noout || echo "Certificate validation failed"
          
          # Note: Skip nginx -t during build since 'api' service won't exist yet
          # The configuration will be tested when the container starts
          
          EXPOSE 80 443
          
          CMD ["nginx", "-g", "daemon off;"]
          EOL
      
      # Step 6: Build and push API image
      - name: Build and push API image
        run: |
          docker compose build api
          docker compose push api
      
      # Step 7: Build and push custom Nginx image
      - name: Build and push Nginx image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Dockerfile.nginx
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai-nginx:latest
      
      # Step 8: Create updated docker-compose.yml for deployment
      - name: Create deployment docker-compose.yml
        run: |
          cat > docker-compose.deploy.yml << EOL
          version: '3.8'
          services:
            api:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai:latest
              depends_on:
                - db
              expose:
                - "5000"
              environment:
                ASPNETCORE_ENVIRONMENT: "Production"
                ConnectionStrings__Database: "Host=db;Port=5432;Database=pulseai;Username=postgres;Password=\${DB_PASSWORD}"
                Jwt__Secret: "\${JWT_SECRET}"
                Jwt__Issuer: "pulseai-api"
                Jwt__Audience: "pulseai-clients"
              networks:
                - pulseai-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
            
            nginx:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai-nginx:latest
              ports:
                - "80:80"
                - "443:443"
              depends_on:
                - api
              networks:
                - pulseai-network
              restart: unless-stopped
              volumes:
                # Optional: Mount Let's Encrypt directory for auto-renewal
                - certbot-data:/var/www/certbot
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost/health"]
                interval: 30s
                timeout: 10s
                retries: 3
            
            db:
              image: postgres:15-alpine
              restart: unless-stopped
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: "\${DB_PASSWORD}"
                POSTGRES_DB: pulseai
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - pulseai-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 30s
                timeout: 10s
                retries: 3
          
          volumes:
            postgres_data:
            certbot-data:
          
          networks:
            pulseai-network:
              driver: bridge
          EOL
      
      # Step 9: Create environment file
      - name: Create environment file
        run: |
          cat > .env << EOL
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          EOL
      
      # Step 10: Setup SSH and Deploy to Droplet
      - name: Setup SSH and Deploy
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH private key to file
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Add droplet to known hosts
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_DROPLET_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # Test SSH connection first
          echo "Testing SSH connection..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} "echo 'SSH connection successful'"
          
          # Create directory on server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} "mkdir -p /opt/pulseai"
          
          # Upload files
          echo "Uploading files..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.deploy.yml .env \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }}:/opt/pulseai/
          
          # Deploy
          echo "Deploying application..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            cd /opt/pulseai
            
            # Backup current deployment
            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.backup
            fi
            
            # Update deployment files
            mv docker-compose.deploy.yml docker-compose.yml
            
            # Install Docker and Docker Compose if not present
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              systemctl start docker
              systemctl enable docker
            fi
            
            # Pull latest images
            docker compose pull
            
            # Stop current containers
            docker compose down
            
            # Start new deployment
            docker compose up -d
            
            # Wait for services to start
            echo "Waiting for services to start..."
            sleep 30
            
            # Check if services are running
            docker compose ps
            
            # Test API health (allow self-signed certificates)
            timeout 60 bash -c 'until curl -f -k https://localhost/health; do sleep 5; done' || echo "Health check failed"
            
            # Show logs for debugging
            docker compose logs --tail=50
          EOF
      
      # Step 11: Optional - Set up certificate auto-renewal
      - name: Setup certificate renewal (Optional)
        if: false  # Set to true to enable
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            # Create renewal script
            cat > /opt/pulseai/renew-certs.sh << 'SCRIPT_EOF'
            #!/bin/bash
            cd /opt/pulseai
            
            # Renew certificates
            docker run --rm \
              -v /opt/pulseai/letsencrypt:/etc/letsencrypt \
              -v /opt/pulseai/certbot:/var/www/certbot \
              certbot/certbot renew --quiet
            
            # Reload nginx if certificates were renewed
            if [ $? -eq 0 ]; then
              docker compose exec nginx nginx -s reload
            fi
          SCRIPT_EOF
            
            chmod +x /opt/pulseai/renew-certs.sh
            
            # Add to crontab (run twice daily)
            (crontab -l 2>/dev/null; echo "0 2,14 * * * /opt/pulseai/renew-certs.sh") | crontab -
          EOF