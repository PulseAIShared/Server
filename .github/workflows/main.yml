name: Deploy to Production with SSL
on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      
      # Step 4: Create nginx configuration for SSL
      - name: Create nginx configuration
        run: |
          cat > nginx.conf << 'EOL'
          events {
              worker_connections 1024;
          }
          
          http {
              # Redirect HTTP to HTTPS
              server {
                  listen 80;
                  server_name ${{ secrets.DOMAIN_NAME }};
                  
                  # Let's Encrypt ACME challenge
                  location /.well-known/acme-challenge/ {
                      root /var/www/certbot;
                  }
                  
                  # Redirect everything else to HTTPS
                  location / {
                      return 301 https://$host$request_uri;
                  }
              }
              
              # HTTPS server
              server {
                  listen 443 ssl;
                  http2 on;
                  server_name ${{ secrets.DOMAIN_NAME }};
                  
                  # SSL Configuration
                  ssl_certificate /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/privkey.pem;
                  
                  # Modern SSL configuration
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
                  ssl_prefer_server_ciphers off;
                  ssl_session_cache shared:SSL:10m;
                  ssl_session_timeout 10m;
                  
                  # Security headers
                  add_header Strict-Transport-Security "max-age=31536000" always;
                  add_header X-Frame-Options "SAMEORIGIN" always;
                  add_header X-Content-Type-Options "nosniff" always;
                  add_header Referrer-Policy "strict-origin-when-cross-origin" always;
                  
                  # CORS headers for your frontend
                  add_header Access-Control-Allow-Origin "https://pulseltv.com" always;
                  add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
                  add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization" always;
                  add_header Access-Control-Allow-Credentials "true" always;
                  
                  # Handle preflight requests
                  if ($request_method = 'OPTIONS') {
                      add_header Access-Control-Allow-Origin "https://pulseltv.com";
                      add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
                      add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
                      add_header Access-Control-Allow-Credentials "true";
                      add_header Access-Control-Max-Age 1728000;
                      add_header Content-Type "text/plain; charset=utf-8";
                      add_header Content-Length 0;
                      return 204;
                  }
                  
                  location / {
                      proxy_pass http://api:5000;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection keep-alive;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $server_name;
                      proxy_cache_bypass $http_upgrade;
                      
                      # Increase timeouts
                      proxy_connect_timeout 60s;
                      proxy_send_timeout 60s;
                      proxy_read_timeout 60s;
                  }
              }
          }
          EOL
      
      # Step 5: Create production docker-compose
      - name: Create production docker-compose
        run: |
          cat > docker-compose.deploy.yml << 'EOL'
          services:
            api:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai:latest
              expose:
                - "5000"
              environment:
                ASPNETCORE_ENVIRONMENT: "Production"
                ASPNETCORE_URLS: "http://+:5000"
                ConnectionStrings__Database: "Host=db;Port=5432;Database=pulseai;Username=postgres;Password=${DB_PASSWORD}"
                Jwt__Secret: "${JWT_SECRET}"
                Jwt__Issuer: "pulseai-api"
                Jwt__Audience: "pulseai-clients"
              networks:
                - pulseai-network
              restart: unless-stopped
              depends_on:
                - db
          
            nginx:
              image: nginx:latest
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf:ro
                - letsencrypt:/etc/letsencrypt:ro
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
              restart: unless-stopped
              depends_on:
                - api
          
            certbot:
              image: certbot/certbot
              volumes:
                - letsencrypt:/etc/letsencrypt
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
          
            db:
              image: postgres:15-alpine
              restart: unless-stopped
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: "${DB_PASSWORD}"
                POSTGRES_DB: pulseai
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - pulseai-network
          
          volumes:
            postgres_data:
            letsencrypt:
            certbot:
          
          networks:
            pulseai-network:
              driver: bridge
          EOL
      
      # Step 6: Build and push API image
      - name: Build and push API image
        run: |
          docker compose build api
          docker compose push api
      
      # Step 7: Create environment file
      - name: Create environment file
        run: |
          cat > .env << EOL
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
          CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
          EOL
      
      # Step 8: Deploy with automatic HTTPS setup
      - name: Deploy with SSL Certificate
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_DROPLET_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # Upload files
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.deploy.yml nginx.conf .env \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }}:/opt/pulseai/
          
          # Deploy with automatic SSL
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            cd /opt/pulseai
            
            # Source environment variables
            set -a
            source .env
            set +a
            
            # Stop existing services
            docker compose down --remove-orphans || true
            
            # Backup current deployment
            [ -f docker-compose.yml ] && cp docker-compose.yml docker-compose.yml.backup
            mv docker-compose.deploy.yml docker-compose.yml
            
            echo "🚀 Starting services..."
            docker compose up -d
            
            # Wait for services to be ready
            echo "⏳ Waiting for services to start..."
            sleep 30
            
            # Check if SSL certificate exists, if not get it
            if [ ! -f "/var/lib/docker/volumes/pulseai_letsencrypt/_data/live/${DOMAIN_NAME}/fullchain.pem" ]; then
              echo "🔒 Getting SSL certificate for ${DOMAIN_NAME}..."
              
              # First, ensure certbot container can access the web root
              docker compose run --rm certbot certonly \
                --webroot \
                --webroot-path=/var/www/certbot \
                --email ${CERTBOT_EMAIL} \
                --agree-tos \
                --no-eff-email \
                --force-renewal \
                -d ${DOMAIN_NAME}
              
              # Restart nginx to load certificate
              echo "🔄 Restarting nginx with SSL certificate..."
              docker compose restart nginx
              sleep 15
            else
              echo "✅ SSL certificate already exists for ${DOMAIN_NAME}"
            fi
            
            # Setup certificate auto-renewal
            (crontab -l 2>/dev/null; echo "0 12 * * * cd /opt/pulseai && docker compose run --rm certbot renew --quiet && docker compose restart nginx") | crontab - 2>/dev/null
            
            echo "📋 Final service status:"
            docker compose ps
            
            echo "🧪 Testing endpoints..."
            
            # Test HTTP redirect
            if curl -s -o /dev/null -w "%{http_code}" http://${DOMAIN_NAME}/health | grep -q "301\|302"; then
              echo "✅ HTTP to HTTPS redirect working"
            else
              echo "⚠️ HTTP redirect may need checking"
            fi
            
            # Test HTTPS
            if curl -f -s https://${DOMAIN_NAME}/health > /dev/null; then
              echo "✅ HTTPS endpoint working"
            else
              echo "❌ HTTPS endpoint failed"
              docker compose logs nginx --tail=10
            fi
            
            # Test CORS
            echo "🔍 Testing CORS headers..."
            CORS_TEST=$(curl -s -H "Origin: https://pulseltv.com" -I https://${DOMAIN_NAME}/health | grep -i "access-control-allow-origin" | wc -l)
            if [ "$CORS_TEST" -eq 1 ]; then
              echo "✅ CORS headers correct"
            else
              echo "⚠️ CORS headers: $CORS_TEST (should be 1)"
            fi
            
            echo ""
            echo "🎉 DEPLOYMENT COMPLETE!"
            echo "========================"
            echo "✅ Your API: https://${DOMAIN_NAME}"
            echo "✅ Health check: https://${DOMAIN_NAME}/health"
            echo "✅ SSL certificate installed"
            echo "✅ Auto-renewal configured"
            echo "✅ Ready for client: https://pulseltv.com"
            
          EOF
      
      # Step 9: Final verification with detailed debugging
      - name: Verify deployment
        run: |
          echo "🔍 Final verification..."
          echo "Testing domain: ${{ secrets.DOMAIN_NAME }}"
          
          # DNS resolution test
          echo "🔍 Testing DNS resolution..."
          nslookup ${{ secrets.DOMAIN_NAME }} || echo "⚠️ DNS resolution failed"
          
          # Test if server responds at all
          echo "🔍 Testing basic connectivity..."
          if ping -c 3 ${{ secrets.DOMAIN_NAME }}; then
            echo "✅ Server is reachable"
          else
            echo "❌ Server is not reachable"
          fi
          
          # Test HTTP (should redirect)
          echo "🔍 Testing HTTP (should redirect to HTTPS)..."
          HTTP_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -L http://${{ secrets.DOMAIN_NAME }}/health || echo "FAILED")
          echo "HTTP response code: $HTTP_RESPONSE"
          
          # Test HTTPS with verbose output
          echo "🔍 Testing HTTPS endpoint with detailed output..."
          HTTPS_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ secrets.DOMAIN_NAME }}/health || echo "FAILED")
          echo "HTTPS response code: $HTTPS_RESPONSE"
          
          # Get more details about the HTTPS request
          echo "🔍 Detailed HTTPS test..."
          curl -v -s https://${{ secrets.DOMAIN_NAME }}/health || echo "Detailed HTTPS test failed"
          
          # Test if containers are running on the server
          echo "🔍 Checking server container status..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            echo "=== Docker containers status ==="
            docker ps
            echo ""
            echo "=== Docker compose logs (last 20 lines) ==="
            cd /opt/pulseai
            docker compose logs --tail=20
            echo ""
            echo "=== Nginx logs (last 10 lines) ==="
            docker compose logs nginx --tail=10
            echo ""
            echo "=== API logs (last 10 lines) ==="
            docker compose logs api --tail=10
          EOF
          
          # Final assessment
          if [ "$HTTPS_RESPONSE" = "200" ]; then
            echo "✅ API is working via HTTPS"
          else
            echo "❌ API verification failed - Response code: $HTTPS_RESPONSE"
            echo "Check the logs above for more details"
            # Don't exit 1 here so we can see all the debug info
          fi
          
          # Test CORS
          echo "🔍 Testing CORS headers..."
          CORS_HEADERS=$(curl -s -H "Origin: https://pulseltv.com" -I https://${{ secrets.DOMAIN_NAME }}/health | grep -i "access-control-allow-origin" | wc -l || echo "0")
          if [ "$CORS_HEADERS" -eq 1 ]; then
            echo "✅ CORS configuration correct"
          else
            echo "⚠️ CORS may have issues - found $CORS_HEADERS origin headers"
          fi
          
          echo ""
          echo "🎯 Target API URL: https://${{ secrets.DOMAIN_NAME }}"
          echo "📋 Check the logs above to debug any issues"