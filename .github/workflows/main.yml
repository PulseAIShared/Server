name: CI/CD Pipeline with Auto Let's Encrypt
on:
  push:
    branches:
      - main
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      
      # Step 4: Create nginx configuration with Let's Encrypt
      - name: Create nginx configuration
        run: |
          # Use domain from secrets, fallback to IP
          DOMAIN="${{ secrets.DOMAIN_NAME }}"
          if [ -z "$DOMAIN" ]; then
            echo "⚠️ DOMAIN_NAME secret not set. Please add your domain to GitHub secrets."
            exit 1
          fi
          
          cat > nginx.conf << EOL
          user  nginx;
          worker_processes  auto;
          
          error_log  /var/log/nginx/error.log notice;
          pid        /var/run/nginx.pid;
          
          events {
              worker_connections  1024;
          }
          
          http {
              include       /etc/nginx/mime.types;
              default_type  application/octet-stream;
              
              sendfile        on;
              keepalive_timeout  65;
              
              # Rate limiting
              limit_req_zone \$binary_remote_addr zone=api:10m rate=100r/s;
              
              # HTTP server for Let's Encrypt and redirects
              server {
                  listen 80;
                  server_name ${DOMAIN};
                  
                  # Let's Encrypt ACME challenge
                  location /.well-known/acme-challenge/ {
                      root /var/www/certbot;
                  }
                  
                  # Redirect to HTTPS
                  location / {
                      return 301 https://\$host\$request_uri;
                  }
              }
              
              # HTTPS server
              server {
                  listen 443 ssl http2;
                  server_name ${DOMAIN};
                  
                  # SSL Configuration
                  ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
                  
                  # Modern SSL configuration
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
                  ssl_prefer_server_ciphers off;
                  ssl_session_cache shared:SSL:10m;
                  ssl_session_timeout 10m;
                  
                  # HSTS
                  add_header Strict-Transport-Security "max-age=31536000" always;
                  
                  # Security headers
                  add_header X-Frame-Options "SAMEORIGIN" always;
                  add_header X-Content-Type-Options "nosniff" always;
                  add_header X-XSS-Protection "1; mode=block" always;
                  add_header Referrer-Policy "strict-origin-when-cross-origin" always;
                  
                  # API endpoints
                  location / {
                      # Rate limiting
                      limit_req zone=api burst=50 nodelay;
                      
                      # CORS headers
                      add_header Access-Control-Allow-Origin "https://pulseretention.netlify.app" always;
                      add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
                      add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization" always;
                      add_header Access-Control-Allow-Credentials "true" always;
                      
                      # Handle preflight requests
                      if (\$request_method = 'OPTIONS') {
                          add_header Access-Control-Allow-Origin "https://pulseretention.netlify.app";
                          add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
                          add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
                          add_header Access-Control-Allow-Credentials "true";
                          add_header Content-Length 0;
                          add_header Content-Type "text/plain charset=UTF-8";
                          return 204;
                      }
                      
                      # Proxy to API
                      proxy_pass http://api:5000;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade \$http_upgrade;
                      proxy_set_header Connection keep-alive;
                      proxy_set_header Host \$host;
                      proxy_set_header X-Real-IP \$remote_addr;
                      proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto \$scheme;
                      proxy_set_header X-Forwarded-Host \$server_name;
                      proxy_cache_bypass \$http_upgrade;
                  }
                  
                  # Health check
                  location /health {
                      proxy_pass http://api:5000/health;
                      access_log off;
                  }
              }
          }
          EOL
      
      # Step 5: Create docker-compose for deployment
      - name: Create deployment docker-compose
        run: |
          cat > docker-compose.deploy.yml << 'EOL'
          version: '3.8'
          services:
            api:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai:latest
              depends_on:
                db:
                  condition: service_healthy
              expose:
                - "5000"
              environment:
                ASPNETCORE_ENVIRONMENT: "Production"
                ASPNETCORE_URLS: "http://+:5000"
                ConnectionStrings__Database: "Host=db;Port=5432;Database=pulseai;Username=postgres;Password=${DB_PASSWORD}"
                Jwt__Secret: "${JWT_SECRET}"
                Jwt__Issuer: "pulseai-api"
                Jwt__Audience: "pulseai-clients"
              networks:
                - pulseai-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 30s
          
            nginx:
              image: nginx:latest
              ports:
                - "80:80"
                - "443:443"
              depends_on:
                api:
                  condition: service_healthy
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf:ro
                - letsencrypt:/etc/letsencrypt:ro
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "-k", "https://localhost/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 60s
          
            certbot:
              image: certbot/certbot
              volumes:
                - letsencrypt:/etc/letsencrypt
                - certbot:/var/www/certbot
              command: certonly --webroot --webroot-path=/var/www/certbot --email ${CERTBOT_EMAIL} --agree-tos --no-eff-email -d ${DOMAIN_NAME}
              depends_on:
                - nginx
              networks:
                - pulseai-network
          
            db:
              image: postgres:15-alpine
              restart: unless-stopped
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: "${DB_PASSWORD}"
                POSTGRES_DB: pulseai
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - pulseai-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5
          
          volumes:
            postgres_data:
            letsencrypt:
            certbot:
          
          networks:
            pulseai-network:
              driver: bridge
          EOL
      
      # Step 6: Build and push API image
      - name: Build and push API image
        run: |
          docker compose build api
          docker compose push api
      
      # Step 7: Create environment file
      - name: Create environment file
        run: |
          cat > .env << EOL
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
          CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
          EOL
      
      # Step 8: Deploy with automatic SSL setup
      - name: Deploy with Let's Encrypt
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_DROPLET_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # Upload files
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.deploy.yml nginx.conf .env \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }}:/opt/pulseai/
          
          # Deploy with automatic SSL
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            cd /opt/pulseai
            
            # Backup and update
            [ -f docker-compose.yml ] && cp docker-compose.yml docker-compose.yml.backup
            mv docker-compose.deploy.yml docker-compose.yml
            
            # Install Docker if needed
            if ! command -v docker &> /dev/null; then
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              systemctl start docker
              systemctl enable docker
            fi
            
            # Stop existing containers
            docker compose down --remove-orphans
            
            # Start nginx first to handle Let's Encrypt challenges
            docker compose up -d nginx
            sleep 30
            
            # Get SSL certificate
            echo "Getting SSL certificate..."
            docker compose run --rm certbot
            
            # Restart nginx to load SSL certificate
            docker compose restart nginx
            sleep 10
            
            # Start remaining services
            docker compose up -d
            
            # Wait for everything to start
            sleep 60
            
            echo "=== Deployment Status ==="
            docker compose ps
            
            echo "=== Testing HTTPS ==="
            if curl -f https://localhost/health; then
              echo "✅ HTTPS working!"
              echo "🌍 Your API is available at: https://${{ secrets.DOMAIN_NAME }}"
            else
              echo "❌ HTTPS test failed"
              docker compose logs nginx
            fi
            
            # Setup auto-renewal
            (crontab -l 2>/dev/null; echo "0 12 * * * cd /opt/pulseai && docker compose run --rm certbot renew && docker compose restart nginx") | crontab -
          EOF