name: CI/CD Pipeline with Let's Encrypt SSL
on:
  push:
    branches:
      - main
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      
      # Step 4: Create nginx configuration for Let's Encrypt
      - name: Create nginx configuration
        run: |
          cat > nginx.conf << 'EOL'
          user  nginx;
          worker_processes  auto;
          
          error_log  /var/log/nginx/error.log notice;
          pid        /var/run/nginx.pid;
          
          events {
              worker_connections  1024;
          }
          
          http {
              include       /etc/nginx/mime.types;
              default_type  application/octet-stream;
              
              log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                                '$status $body_bytes_sent "$http_referer" '
                                '"$http_user_agent" "$http_x_forwarded_for"';
              
              access_log  /var/log/nginx/access.log  main;
              
              sendfile        on;
              keepalive_timeout  65;
              
              # Rate limiting
              limit_req_zone $binary_remote_addr zone=api:10m rate=100r/s;
              
              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header Referrer-Policy "strict-origin-when-cross-origin" always;
              
              # HTTP server - handles Let's Encrypt challenges and redirects
              server {
                  listen 80;
                  server_name ${{ secrets.DOMAIN_NAME || secrets.DIGITALOCEAN_DROPLET_IP }};
                  
                  # Let's Encrypt ACME challenge
                  location /.well-known/acme-challenge/ {
                      root /var/www/certbot;
                      try_files $uri $uri/ =404;
                  }
                  
                  # Allow health checks over HTTP
                  location /health {
                      proxy_pass http://api:5000/health;
                      access_log off;
                  }
                  
                  # Redirect all other HTTP traffic to HTTPS (only if SSL exists)
                  location / {
                      # Check if SSL certificate exists, if not serve over HTTP
                      if (-f /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME || 'default' }}/fullchain.pem) {
                          return 301 https://$host$request_uri;
                      }
                      
                      # Serve over HTTP if no SSL certificate
                      proxy_pass http://api:5000;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection keep-alive;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $server_name;
                      proxy_cache_bypass $http_upgrade;
                      
                      # Rate limiting
                      limit_req zone=api burst=50 nodelay;
                      
                      # CORS headers for HTTP fallback
                      add_header Access-Control-Allow-Origin "https://pulseretention.netlify.app" always;
                      add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
                      add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization" always;
                      add_header Access-Control-Allow-Credentials "true" always;
                      
                      # Handle preflight requests
                      if ($request_method = 'OPTIONS') {
                          add_header Access-Control-Allow-Origin "https://pulseretention.netlify.app";
                          add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
                          add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
                          add_header Access-Control-Allow-Credentials "true";
                          add_header Content-Length 0;
                          add_header Content-Type text/plain;
                          return 204;
                      }
                  }
              }
              
              # HTTPS server (only active if SSL certificate exists)
              server {
                  listen 443 ssl http2;
                  server_name ${{ secrets.DOMAIN_NAME || secrets.DIGITALOCEAN_DROPLET_IP }};
                  
                  # SSL Configuration - paths for Let's Encrypt
                  ssl_certificate /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME || 'default' }}/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME || 'default' }}/privkey.pem;
                  
                  # Modern SSL configuration
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
                  ssl_prefer_server_ciphers off;
                  ssl_session_timeout 1d;
                  ssl_session_cache shared:SSL:50m;
                  ssl_stapling on;
                  ssl_stapling_verify on;
                  
                  # HSTS (uncomment when SSL is stable)
                  # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
                  
                  # API endpoints
                  location / {
                      # Rate limiting
                      limit_req zone=api burst=50 nodelay;
                      
                      # Proxy configuration
                      proxy_pass http://api:5000;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection keep-alive;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $server_name;
                      proxy_cache_bypass $http_upgrade;
                      
                      # Timeouts
                      proxy_connect_timeout 30s;
                      proxy_send_timeout 30s;
                      proxy_read_timeout 30s;
                      
                      # Buffer settings
                      proxy_buffering on;
                      proxy_buffer_size 4k;
                      proxy_buffers 8 4k;
                  }
                  
                  # Health check endpoint
                  location /health {
                      access_log off;
                      proxy_pass http://api:5000/health;
                  }
              }
          }
          EOL
      
      # Step 5: Create Dockerfile for nginx with Let's Encrypt support
      - name: Create nginx Dockerfile
        run: |
          cat > Dockerfile.nginx << 'EOL'
          FROM nginx:latest
          
          # Install certbot and other utilities
          RUN apt-get update && apt-get install -y \
              certbot \
              python3-certbot-nginx \
              curl \
              cron \
              && rm -rf /var/lib/apt/lists/*
          
          # Create necessary directories
          RUN mkdir -p /var/www/certbot /etc/letsencrypt/live /etc/letsencrypt/archive
          
          # Copy the nginx configuration
          COPY nginx.conf /etc/nginx/nginx.conf
          
          # Create SSL certificate renewal script
          RUN echo '#!/bin/bash\n\
          certbot renew --quiet --webroot --webroot-path=/var/www/certbot\n\
          nginx -s reload\n\
          ' > /usr/local/bin/renew-certs.sh && chmod +x /usr/local/bin/renew-certs.sh
          
          # Create initialization script
          RUN echo '#!/bin/bash\n\
          echo "Starting nginx with SSL support..."\n\
          \n\
          # Start nginx in background\n\
          nginx\n\
          \n\
          # Wait for nginx to start\n\
          sleep 5\n\
          \n\
          # If domain is set and no certificate exists, try to get one\n\
          if [ ! -z "$DOMAIN_NAME" ] && [ ! -f "/etc/letsencrypt/live/$DOMAIN_NAME/fullchain.pem" ]; then\n\
              echo "Attempting to get SSL certificate for $DOMAIN_NAME..."\n\
              certbot certonly --webroot \\\n\
                  --webroot-path=/var/www/certbot \\\n\
                  --email "$CERTBOT_EMAIL" \\\n\
                  --agree-tos \\\n\
                  --no-eff-email \\\n\
                  -d "$DOMAIN_NAME" || echo "SSL certificate generation failed, continuing with HTTP"\n\
              \n\
              # Reload nginx to pick up new certificates\n\
              nginx -s reload\n\
          fi\n\
          \n\
          # Setup certificate renewal cron job\n\
          echo "0 12 * * * /usr/local/bin/renew-certs.sh" | crontab -\n\
          cron\n\
          \n\
          # Keep nginx running in foreground\n\
          nginx -s stop\n\
          exec nginx -g "daemon off;"\n\
          ' > /docker-entrypoint.sh && chmod +x /docker-entrypoint.sh
          
          EXPOSE 80 443
          
          ENTRYPOINT ["/docker-entrypoint.sh"]
          EOL
      
      # Step 6: Build and push API image
      - name: Build and push API image
        run: |
          docker compose build api
          docker compose push api
      
      # Step 7: Build and push custom Nginx image
      - name: Build and push Nginx image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: Dockerfile.nginx
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai-nginx:latest
      
      # Step 8: Create updated docker-compose.yml for deployment
      - name: Create deployment docker-compose.yml
        run: |
          cat > docker-compose.deploy.yml << EOL
          version: '3.8'
          services:
            api:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai:latest
              depends_on:
                - db
              expose:
                - "5000"
              environment:
                ASPNETCORE_ENVIRONMENT: "Production"
                ConnectionStrings__Database: "Host=db;Port=5432;Database=pulseai;Username=postgres;Password=\${DB_PASSWORD}"
                Jwt__Secret: "\${JWT_SECRET}"
                Jwt__Issuer: "pulseai-api"
                Jwt__Audience: "pulseai-clients"
              networks:
                - pulseai-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
            
            nginx:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai-nginx:latest
              ports:
                - "80:80"
                - "443:443"
              depends_on:
                - api
              environment:
                DOMAIN_NAME: "\${DOMAIN_NAME:-}"
                CERTBOT_EMAIL: "\${CERTBOT_EMAIL:-admin@example.com}"
              volumes:
                - letsencrypt:/etc/letsencrypt
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
            
            db:
              image: postgres:15-alpine
              restart: unless-stopped
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: "\${DB_PASSWORD}"
                POSTGRES_DB: pulseai
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - pulseai-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 30s
                timeout: 10s
                retries: 3
          
          volumes:
            postgres_data:
            letsencrypt:
            certbot:
          
          networks:
            pulseai-network:
              driver: bridge
          EOL
      
      # Step 9: Create environment file
      - name: Create environment file
        run: |
          cat > .env << EOL
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME || '' }}
          CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL || 'admin@example.com' }}
          EOL
      
      # Step 10: Setup SSH and Deploy to Droplet
      - name: Setup SSH and Deploy
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH private key to file
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Add droplet to known hosts
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_DROPLET_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # Test SSH connection first
          echo "Testing SSH connection..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} "echo 'SSH connection successful'"
          
          # Create directory on server
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} "mkdir -p /opt/pulseai"
          
          # Upload files
          echo "Uploading files..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.deploy.yml .env \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }}:/opt/pulseai/
          
          # Deploy
          echo "Deploying application..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            cd /opt/pulseai
            
            # Backup current deployment
            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.backup
            fi
            
            # Update deployment files
            mv docker-compose.deploy.yml docker-compose.yml
            
            # Install Docker and Docker Compose if not present
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              systemctl start docker
              systemctl enable docker
            fi
            
            # Pull latest images
            docker compose pull
            
            # Stop current containers (but preserve volumes)
            docker compose down --remove-orphans
            
            # Clean up old containers and images
            docker system prune -f
            
            # Start new deployment
            echo "Starting services..."
            docker compose up -d
            
            # Wait for services to start
            echo "Waiting for services to initialize..."
            sleep 45
            
            # Check if services are running
            echo "=== Service Status ==="
            docker compose ps
            
            # Test API health over HTTP first
            echo "=== Testing HTTP health endpoint ==="
            timeout 60 bash -c 'until curl -f http://localhost/health; do echo "Waiting for HTTP health..."; sleep 5; done' || echo "HTTP health check failed"
            
            # If domain is configured, also test HTTPS
            if [ ! -z "$DOMAIN_NAME" ]; then
              echo "=== Testing HTTPS health endpoint ==="
              timeout 60 bash -c 'until curl -f -k https://localhost/health; do echo "Waiting for HTTPS health..."; sleep 5; done' || echo "HTTPS health check failed"
            fi
            
            # Show logs for debugging
            echo "=== Recent logs ==="
            docker compose logs --tail=30
            
            echo "=== Deployment Summary ==="
            echo "HTTP endpoint: http://${{ secrets.DIGITALOCEAN_DROPLET_IP }}"
            if [ ! -z "$DOMAIN_NAME" ]; then
              echo "Domain endpoint: https://$DOMAIN_NAME (if SSL certificate was generated)"
            fi
            echo "Health check: http://${{ secrets.DIGITALOCEAN_DROPLET_IP }}/health"
          EOF
      
      # Step 11: Post-deployment verification
      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          
          # Wait a bit more for services to fully start
          sleep 30
          
          # Test the API endpoint
          if curl -f -m 30 http://${{ secrets.DIGITALOCEAN_DROPLET_IP }}/health; then
            echo "✅ API is accessible via HTTP"
          else
            echo "❌ API health check failed"
            exit 1
          fi
          
          echo "🚀 Deployment completed successfully!"
          echo "📍 API URL: http://${{ secrets.DIGITALOCEAN_DROPLET_IP }}"
          echo "🔗 Use this URL in your client: http://${{ secrets.DIGITALOCEAN_DROPLET_IP }}"