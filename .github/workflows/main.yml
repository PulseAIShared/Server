name: Deploy to Production with SSL
on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      
      # Step 4: Create nginx configuration (FIXED CORS VERSION)
      - name: Create nginx configuration
        run: |
          cat > nginx.conf << 'EOL'
          events {
              worker_connections 1024;
          }
          
          http {
              server {
                  listen 80;
                  server_name ${{ secrets.DOMAIN_NAME }};
                  
                  location /.well-known/acme-challenge/ {
                      root /var/www/certbot;
                  }
                  
                  location / {
                      return 301 https://$host$request_uri;
                  }
              }
              
              server {
                  listen 443 ssl;
                  server_name ${{ secrets.DOMAIN_NAME }};
                  
                  ssl_certificate /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/privkey.pem;
                  
                  # Remove CORS headers from nginx - let the API handle them
                  # This prevents duplicate headers
                  
                  location / {
                      proxy_pass http://api:5000;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection "upgrade";
                      
                      # Hide any existing CORS headers from upstream to prevent duplicates
                      proxy_hide_header Access-Control-Allow-Origin;
                      proxy_hide_header Access-Control-Allow-Methods;
                      proxy_hide_header Access-Control-Allow-Headers;
                      proxy_hide_header Access-Control-Allow-Credentials;
                  }
              }
          }
          EOL
      
      # Step 5: Create production docker-compose
      - name: Create production docker-compose
        run: |
          cat > docker-compose.deploy.yml << 'EOL'
          services:
            api:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai:latest
              expose:
                - "5000"
              environment:
                ASPNETCORE_ENVIRONMENT: "Production"
                ASPNETCORE_URLS: "http://+:5000"
                ConnectionStrings__Database: "Host=db;Port=5432;Database=pulseai;Username=postgres;Password=${DB_PASSWORD}"
                Jwt__Secret: "${JWT_SECRET}"
                Jwt__Issuer: "pulseai-api"
                Jwt__Audience: "pulseai-clients"
                # Ensure API handles CORS properly
                CORS__AllowedOrigins: "https://pulseltv.com"
              networks:
                - pulseai-network
              restart: unless-stopped
              depends_on:
                - db
          
            nginx:
              image: nginx:latest
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf:ro
                - letsencrypt:/etc/letsencrypt:ro
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
              restart: unless-stopped
              depends_on:
                - api
          
            certbot:
              image: certbot/certbot
              volumes:
                - letsencrypt:/etc/letsencrypt
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
          
            db:
              image: postgres:15-alpine
              restart: unless-stopped
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: "${DB_PASSWORD}"
                POSTGRES_DB: pulseai
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - pulseai-network
          
          volumes:
            postgres_data:
            letsencrypt:
            certbot:
          
          networks:
            pulseai-network:
              driver: bridge
          EOL
      
      # Step 6: Build and push API image (FORCE FRESH BUILD)
      - name: Build and push API image
        run: |
          # Build with no cache to ensure fresh build
          docker compose build --no-cache --pull api
          docker compose push api
      
      # Step 7: Create environment file
      - name: Create environment file
        run: |
          cat > .env << EOL
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
          CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
          EOL
      
      # Step 8: Deploy with automatic HTTPS setup
      - name: Deploy with SSL Certificate
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_DROPLET_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # Upload files
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.deploy.yml nginx.conf .env \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }}:/opt/pulseai/
          
          # Deploy with automatic SSL
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            cd /opt/pulseai
            
            # Source environment variables
            set -a
            source .env
            set +a
            
            # Stop existing services
            docker compose down --remove-orphans || true
            
            # Backup current deployment
            [ -f docker-compose.yml ] && cp docker-compose.yml docker-compose.yml.backup
            mv docker-compose.deploy.yml docker-compose.yml
            
            echo "🚀 Starting services..."
            docker compose up -d
            
            # Wait for services to be ready
            echo "⏳ Waiting for services to start..."
            sleep 30
            
            # Check if SSL certificate exists, if not get it
            if [ ! -f "/var/lib/docker/volumes/pulseai_letsencrypt/_data/live/${DOMAIN_NAME}/fullchain.pem" ]; then
              echo "🔒 Getting SSL certificate for ${DOMAIN_NAME}..."
              
              # Get SSL certificate
              docker compose run --rm certbot certonly \
                --webroot \
                --webroot-path=/var/www/certbot \
                --email ${CERTBOT_EMAIL} \
                --agree-tos \
                --no-eff-email \
                --force-renewal \
                -d ${DOMAIN_NAME}
              
              # Restart nginx to load certificate
              echo "🔄 Restarting nginx with SSL certificate..."
              docker compose restart nginx
              sleep 15
            else
              echo "✅ SSL certificate already exists for ${DOMAIN_NAME}"
            fi
            
            # Setup certificate auto-renewal
            (crontab -l 2>/dev/null; echo "0 12 * * * cd /opt/pulseai && docker compose run --rm certbot renew --quiet && docker compose restart nginx") | crontab - 2>/dev/null
            
            echo "📋 Final service status:"
            docker compose ps
            
            echo "🧪 Testing endpoints..."
            
            # Test HTTP redirect
            if curl -s -o /dev/null -w "%{http_code}" http://${DOMAIN_NAME}/health | grep -q "301\|302"; then
              echo "✅ HTTP to HTTPS redirect working"
            else
              echo "⚠️ HTTP redirect may need checking"
            fi
            
            # Test HTTPS
            if curl -f -s https://${DOMAIN_NAME}/health > /dev/null; then
              echo "✅ HTTPS endpoint working"
            else
              echo "❌ HTTPS endpoint failed"
              docker compose logs nginx --tail=10
            fi
            
            # Test CORS with detailed output
            echo "🔍 Testing CORS headers in detail..."
            CORS_RESPONSE=$(curl -s -H "Origin: https://pulseltv.com" -I https://${DOMAIN_NAME}/health)
            echo "CORS Response headers:"
            echo "$CORS_RESPONSE" | grep -i "access-control"
            
            CORS_COUNT=$(echo "$CORS_RESPONSE" | grep -i "access-control-allow-origin" | wc -l)
            if [ "$CORS_COUNT" -eq 1 ]; then
              echo "✅ CORS headers correct (exactly 1 origin header)"
            elif [ "$CORS_COUNT" -gt 1 ]; then
              echo "❌ CORS headers duplicated ($CORS_COUNT origin headers found)"
              echo "This indicates both nginx and API are setting CORS headers"
            else
              echo "⚠️ No CORS headers found"
            fi
            
            echo ""
            echo "🎉 DEPLOYMENT COMPLETE!"
            echo "========================"
            echo "✅ Your API: https://${DOMAIN_NAME}"
            echo "✅ Health check: https://${DOMAIN_NAME}/health"
            echo "✅ SSL certificate installed"
            echo "✅ Auto-renewal configured"
            echo "✅ CORS issue should be resolved"
            echo "✅ Ready for client: https://pulseltv.com"
            
          EOF
      
      # Step 9: Final verification with CORS focus
      - name: Verify deployment and CORS
        run: |
          echo "🔍 Final verification with CORS focus..."
          echo "Testing domain: ${{ secrets.DOMAIN_NAME }}"
          
          # Test CORS specifically
          echo "🔍 Testing CORS headers with multiple methods..."
          
          # Method 1: Simple preflight test
          echo "--- Method 1: Simple CORS test ---"
          curl -s -H "Origin: https://pulseltv.com" -I https://${{ secrets.DOMAIN_NAME }}/health | grep -i "access-control" || echo "No CORS headers found"
          
          # Method 2: OPTIONS preflight request
          echo "--- Method 2: OPTIONS preflight test ---"
          curl -s -X OPTIONS \
            -H "Origin: https://pulseltv.com" \
            -H "Access-Control-Request-Method: GET" \
            -H "Access-Control-Request-Headers: Authorization" \
            -I https://${{ secrets.DOMAIN_NAME }}/users/me | grep -i "access-control" || echo "No CORS headers in OPTIONS"
          
          # Method 3: Count duplicate headers
          echo "--- Method 3: Header count verification ---"
          HEADER_COUNT=$(curl -s -H "Origin: https://pulseltv.com" -I https://${{ secrets.DOMAIN_NAME }}/health | grep -i "access-control-allow-origin" | wc -l)
          echo "Access-Control-Allow-Origin header count: $HEADER_COUNT"
          
          if [ "$HEADER_COUNT" -eq 1 ]; then
            echo "✅ CORS configuration is correct"
          elif [ "$HEADER_COUNT" -gt 1 ]; then
            echo "❌ Still have duplicate CORS headers"
            echo "You may need to disable CORS in your ASP.NET Core application"
          else
            echo "⚠️ No CORS headers - API may not be handling them"
          fi
          
          # Check server logs for any CORS-related errors
          echo "🔍 Checking server logs for CORS issues..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            cd /opt/pulseai
            echo "=== Recent API logs (looking for CORS) ==="
            docker compose logs api --tail=50 | grep -i "cors\|origin\|preflight" || echo "No CORS-related logs found"
            echo ""
            echo "=== Recent nginx access logs ==="
            docker compose logs nginx --tail=20 | grep -i "OPTIONS\|cors" || echo "No CORS-related nginx logs"
          EOF
          
          echo ""
          echo "🎯 If you still see CORS issues after this deployment:"
          echo "1. Check your ASP.NET Core Startup.cs or Program.cs"
          echo "2. Make sure CORS is configured to only allow 'https://pulseltv.com'"
          echo "3. Consider temporarily disabling CORS in your API to let nginx handle it"