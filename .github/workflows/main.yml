name: Deploy to Production with SSL
on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      
      # Step 4: Create nginx configuration (FIXED - CORS headers removed)
      - name: Create nginx configuration
        run: |
          cat > nginx.conf << 'EOL'
          events {
              worker_connections 1024;
          }
          
          http {
              # Map for WebSocket connection upgrades
              map $http_upgrade $connection_upgrade {
                  default upgrade;
                  '' close;
              }
              
              server {
                  listen 80;
                  server_name ${{ secrets.DOMAIN_NAME }};
                  
                  location /.well-known/acme-challenge/ {
                      root /var/www/certbot;
                  }
                  
                  location / {
                      return 301 https://$host$request_uri;
                  }
              }
              
              server {
                  listen 443 ssl;
                  server_name ${{ secrets.DOMAIN_NAME }};
                  
                  ssl_certificate /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/privkey.pem;
                  
                  # SSL Settings (recommended)
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_prefer_server_ciphers on;
                  ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
                  ssl_session_timeout 1d;
                  ssl_session_cache shared:SSL:10m;
                  
                  # CORS headers REMOVED - let .NET handle CORS to prevent duplicates
                  
                  # Special location for SignalR WebSocket connections
                  location /hubs/ {
                      proxy_pass http://api:5000;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection "upgrade";
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $host;
                      proxy_set_header X-Forwarded-Port $server_port;
                      proxy_cache_bypass $http_upgrade;
                      
                      # WebSocket specific settings
                      proxy_read_timeout 86400;
                      proxy_send_timeout 86400;
                      proxy_connect_timeout 86400;
                      
                      # Disable buffering for real-time communication
                      proxy_buffering off;
                  }
                  
                  # General location for all other API requests
                  location / {
                      proxy_pass http://api:5000;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                      proxy_set_header X-Forwarded-Host $host;
                      proxy_set_header X-Forwarded-Port $server_port;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection $connection_upgrade;
                      proxy_cache_bypass $http_upgrade;
                      
                      # Standard timeouts for regular requests
                      proxy_read_timeout 300;
                      proxy_send_timeout 300;
                      proxy_connect_timeout 300;
                  }
              }
          }
          EOL
      
      # Step 5: Create production docker-compose
      - name: Create production docker-compose
        run: |
          cat > docker-compose.deploy.yml << 'EOL'
          services:
            api:
              image: ${{ secrets.DOCKER_HUB_USERNAME }}/pulseai:latest
              expose:
                - "5000"
              environment:
                ASPNETCORE_ENVIRONMENT: "Production"
                ASPNETCORE_URLS: "http://+:5000"
                ConnectionStrings__Database: "Host=db;Port=5432;Database=pulseai;Username=postgres;Password=${DB_PASSWORD}"
                Jwt__Secret: "${JWT_SECRET}"
                Jwt__Issuer: "pulseai-api"
                Jwt__Audience: "pulseai-clients"
              networks:
                - pulseai-network
              restart: unless-stopped
              depends_on:
                - db
          
            nginx:
              image: nginx:latest
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - ./nginx.conf:/etc/nginx/nginx.conf:ro
                - letsencrypt:/etc/letsencrypt:ro
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
              restart: unless-stopped
              depends_on:
                - api
          
            certbot:
              image: certbot/certbot
              volumes:
                - letsencrypt:/etc/letsencrypt
                - certbot:/var/www/certbot
              networks:
                - pulseai-network
          
            db:
              image: postgres:15-alpine
              restart: unless-stopped
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: "${DB_PASSWORD}"
                POSTGRES_DB: pulseai
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - pulseai-network
          
          volumes:
            postgres_data:
            letsencrypt:
            certbot:
          
          networks:
            pulseai-network:
              driver: bridge
          EOL
      
      # Step 6: Build and push API image
      - name: Build and push API image
        run: |
          docker compose build api
          docker compose push api
      
      # Step 7: Create environment file
      - name: Create environment file
        run: |
          cat > .env << EOL
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
          CERTBOT_EMAIL=${{ secrets.CERTBOT_EMAIL }}
          EOL
      
      # Step 8: Deploy with automatic HTTPS setup
      - name: Deploy with SSL Certificate
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.DIGITALOCEAN_DROPLET_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # Upload files
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.deploy.yml nginx.conf .env \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }}:/opt/pulseai/
          
          # Deploy with automatic SSL
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            cd /opt/pulseai
            
            # Source environment variables
            set -a
            source .env
            set +a
            
            # Stop existing services
            docker compose down --remove-orphans || true
            
            # Backup current deployment
            [ -f docker-compose.yml ] && cp docker-compose.yml docker-compose.yml.backup
            mv docker-compose.deploy.yml docker-compose.yml
            
            echo "🚀 Starting services..."
            docker compose up -d
            
            # Wait for services to be ready
            echo "⏳ Waiting for services to start..."
            sleep 30
            
            # Check if SSL certificate exists, if not get it
            if [ ! -f "/var/lib/docker/volumes/pulseai_letsencrypt/_data/live/${DOMAIN_NAME}/fullchain.pem" ]; then
              echo "🔒 Getting SSL certificate for ${DOMAIN_NAME}..."
              
              # Get SSL certificate
              docker compose run --rm certbot certonly \
                --webroot \
                --webroot-path=/var/www/certbot \
                --email ${CERTBOT_EMAIL} \
                --agree-tos \
                --no-eff-email \
                --force-renewal \
                -d ${DOMAIN_NAME}
              
              # Restart nginx to load certificate
              echo "🔄 Restarting nginx with SSL certificate..."
              docker compose restart nginx
              sleep 15
            else
              echo "✅ SSL certificate already exists for ${DOMAIN_NAME}"
            fi
            
            # Setup certificate auto-renewal
            (crontab -l 2>/dev/null; echo "0 12 * * * cd /opt/pulseai && docker compose run --rm certbot renew --quiet && docker compose restart nginx") | crontab - 2>/dev/null
            
            echo "📋 Final service status:"
            docker compose ps
            
            echo "🧪 Testing endpoints..."
            
            # Test HTTP redirect
            if curl -s -o /dev/null -w "%{http_code}" http://${DOMAIN_NAME}/health | grep -q "301\|302"; then
              echo "✅ HTTP to HTTPS redirect working"
            else
              echo "⚠️ HTTP redirect may need checking"
            fi
            
            # Test HTTPS
            if curl -f -s https://${DOMAIN_NAME}/health > /dev/null; then
              echo "✅ HTTPS endpoint working"
            else
              echo "❌ HTTPS endpoint failed"
              docker compose logs nginx --tail=10
            fi
            
            # Test WebSocket connection for SignalR
            echo "🔌 Testing WebSocket/SignalR connection..."
            WS_TEST=$(curl -s -I https://${DOMAIN_NAME}/hubs/notifications 2>/dev/null | head -1 | grep -o "404\|200\|101" || echo "FAILED")
            if [ "$WS_TEST" = "404" ] || [ "$WS_TEST" = "200" ]; then
              echo "✅ SignalR hub endpoint accessible (got $WS_TEST)"
            else
              echo "⚠️ SignalR hub endpoint test: $WS_TEST"
            fi
            
            echo ""
            echo "🎉 DEPLOYMENT COMPLETE!"
            echo "========================"
            echo "✅ Your API: https://${DOMAIN_NAME}"
            echo "✅ Health check: https://${DOMAIN_NAME}/health"
            echo "✅ SSL certificate installed"
            echo "✅ Auto-renewal configured"
            echo "✅ CORS configured in .NET (no nginx duplicates)"
            echo "✅ WebSocket/SignalR support enabled"
            echo "✅ Ready for client: https://pulseltv.com"
            
          EOF
      
      # Step 9: Final verification with detailed debugging
      - name: Verify deployment
        run: |
          echo "🔍 Final verification..."
          echo "Testing domain: ${{ secrets.DOMAIN_NAME }}"
          
          # DNS resolution test
          echo "🔍 Testing DNS resolution..."
          nslookup ${{ secrets.DOMAIN_NAME }} || echo "⚠️ DNS resolution failed"
          
          # Test if server responds at all
          echo "🔍 Testing basic connectivity..."
          if ping -c 3 ${{ secrets.DOMAIN_NAME }}; then
            echo "✅ Server is reachable"
          else
            echo "❌ Server is not reachable"
          fi
          
          # Test HTTP (should redirect)
          echo "🔍 Testing HTTP (should redirect to HTTPS)..."
          HTTP_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -L http://${{ secrets.DOMAIN_NAME }}/health || echo "FAILED")
          echo "HTTP response code: $HTTP_RESPONSE"
          
          # Test HTTPS with verbose output
          echo "🔍 Testing HTTPS endpoint with detailed output..."
          HTTPS_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ secrets.DOMAIN_NAME }}/health || echo "FAILED")
          echo "HTTPS response code: $HTTPS_RESPONSE"
          
          # Get more details about the HTTPS request
          echo "🔍 Detailed HTTPS test..."
          curl -v -s https://${{ secrets.DOMAIN_NAME }}/health || echo "Detailed HTTPS test failed"
          
          # Test CORS specifically (this is the key fix)
          echo "🔍 Testing CORS headers for duplicate origin issue..."
          CORS_TEST=$(curl -s -H "Origin: https://pulseltv.com" -I https://${{ secrets.DOMAIN_NAME }}/health 2>/dev/null | grep -i "access-control-allow-origin" | wc -l || echo "0")
          CORS_CONTENT=$(curl -s -H "Origin: https://pulseltv.com" -I https://${{ secrets.DOMAIN_NAME }}/health 2>/dev/null | grep -i "access-control-allow-origin" || echo "No CORS headers")
          
          echo "CORS header count: $CORS_TEST"
          echo "CORS header content: $CORS_CONTENT"
          
          if [ "$CORS_TEST" -eq 1 ]; then
            echo "✅ CORS configuration correct (single origin header)"
          elif [ "$CORS_TEST" -eq 0 ]; then
            echo "⚠️ No CORS headers found - check .NET CORS configuration"
          else
            echo "❌ Multiple CORS headers detected ($CORS_TEST) - still have duplicate issue"
          fi
          
          # Test WebSocket/SignalR endpoint
          echo "🔌 Testing SignalR WebSocket endpoint..."
          SIGNALR_TEST=$(curl -s -o /dev/null -w "%{http_code}" https://${{ secrets.DOMAIN_NAME }}/hubs/notifications || echo "FAILED")
          echo "SignalR hub response: $SIGNALR_TEST"
          if [ "$SIGNALR_TEST" = "404" ] || [ "$SIGNALR_TEST" = "200" ]; then
            echo "✅ SignalR hub endpoint accessible"
          else
            echo "⚠️ SignalR hub may have issues"
          fi
          
          # Test if containers are running on the server
          echo "🔍 Checking server container status..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            root@${{ secrets.DIGITALOCEAN_DROPLET_IP }} << 'EOF'
            echo "=== Docker containers status ==="
            docker ps
            echo ""
            echo "=== Docker compose logs (last 20 lines) ==="
            cd /opt/pulseai
            docker compose logs --tail=20
            echo ""
            echo "=== Nginx logs (last 10 lines) ==="
            docker compose logs nginx --tail=10
            echo ""
            echo "=== API logs (last 10 lines) ==="
            docker compose logs api --tail=10
          EOF
          
          # Final assessment
          if [ "$HTTPS_RESPONSE" = "200" ]; then
            echo "✅ API is working via HTTPS"
          else
            echo "❌ API verification failed - Response code: $HTTPS_RESPONSE"
            echo "Check the logs above for more details"
          fi
          
          if [ "$CORS_TEST" -eq 1 ]; then
            echo "✅ CORS issue should be resolved - single origin header detected"
          else
            echo "⚠️ CORS may still have issues - found $CORS_TEST origin headers"
          fi
          
          if [ "$SIGNALR_TEST" = "404" ] || [ "$SIGNALR_TEST" = "200" ]; then
            echo "✅ SignalR WebSocket should work properly"
          else
            echo "⚠️ SignalR WebSocket may have issues - response: $SIGNALR_TEST"
          fi
          
          echo ""
          echo "🎯 Target API URL: https://${{ secrets.DOMAIN_NAME }}"
          echo "🌐 Frontend URL: https://pulseltv.com"
          echo "📋 CORS should now work properly without duplicate headers"
          echo "🔌 SignalR WebSocket connections should work properly"
          echo "📋 Check the logs above to debug any remaining issues"